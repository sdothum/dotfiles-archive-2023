#!/usr/bin/dash
# sdothum - 2016 (c) wtfpl

# Font
# ══════════════════════════════════════════════════════════════════════════════

# ................................................. monolegible font adjustments
# see make_install iosevka

usage() { 
  echo "usage: $(basename $0) Q_hook | q_hook | I_descending <shape> [raw]
       $(basename $0) Q_custom <shape>
       $(basename $0) Q_horizontal <shape>
       $(basename $0) T_descending <shape> [raw]
       $(basename $0) t_descending <shape>
       $(basename $0) Y_descending <shape> [raw]
       $(basename $0) FP_descending <shape>
       $(basename $0) punctuation <emdash> <shape>
       $(basename $0) ligature <width> <shape>
       $(basename $0) dyslexic <space>
       $(basename $0) bookweight [book+regular]
       $(basename $0) copy <family> <name>, font alias via commandline only
       $(basename $0) map  <family> <glyph> <glyph>, map U+<glyph> via commandline only"
  exit 1
}

MAKE_INSTALL=/tmp/iosevka:make_install
REPO=/net/depot/Iosevka
ANGLE=-9     # iosevka italic angle (verify with fontforge)
Xshift=-40   # italic descending capital left side bearing shift
Yshift=-174  # default descending capital elongation

confirm() { [ -e $MAKE_INSTALL ] && ditto "$(basename $0)" "$1" || { ifyes "$1" || exit; }; }
percent() { echo "$1 * 100" | bc | cut -d. -f1; }
regular() { ls -1 | grep -Ev 'italic|oblique|extended'; }
italic()  { ls -1 | grep -E  'italic'; }

replace() {
  echo "
Select($2);
Copy();
Select($1);
Paste();
"
}

# substitute curly tail q
q_hook() {
  # copy char 0u024b and paste to char 0u0071
  # confirm 'atkinson q-hook'  # see iosevka
  echo "
Open(\$1);
$(replace 0u0071 0u024b)
Generate(\$1);
" >/tmp/fontforge.script

  for i in *ttf ;do
    ditto q_hook $i
    fontforge --script /tmp/fontforge.script $i
  done
}

Q_hook() {
  # copy char 0u024a and paste to char 0u0051
  # confirm 'Q-hook'  # see iosevka
  echo "
Open(\$1);
$(replace 0u0051 0u024a)
Generate(\$1);
" >/tmp/fontforge.script

  for i in *ttf ;do
    ditto Q_hook $i
    fontforge --script /tmp/fontforge.script $i
  done
}

overlay() {
  echo "
Select($2);
CopyReference();
Select($1);
PasteWithOffset($3,$4);
"
}

Q_custom() {
  # copy char 0u03d8 and paste to char 0u0051
  # confirm 'Q-custom'  # see iosevka
  # $(overlay 0u0051 0u0325 $(( $shape / 3 * 4 )) 35)  # circle to cell edge
  # $(overlay 0u0051 0u0325 $(( $shape / 4 * 5 )) 35)  # circle to glyph edge
  Q_offset() {
    echo "
Open(\$1);
$(replace 0u0051 0u004f)
$(overlay 0u0051 0u2035 $x -650)
Generate(\$1);
" >/tmp/fontforge.script
}

  for i in *ttf ;do
    ditto Q_custom $i
    echo $i | grep -E -q 'italic|oblique' && x=-$(( $shape / 13 )) || x=$(( $shape / 10 ))
    Q_offset  # offset dependencies
    fontforge --script /tmp/fontforge.script $i
  done
}

# wide cell width punctuation emdash and ellipsis
punctuation() {
  width=$(percent $emdash)
  confirm "${emdash}x width emdash"
  
  echo "
Open(\$1);
Select(0u2012);
Copy();
Select(0u2014);
Paste();
Transform($width,0,0,100,0,0);
Select(0u2026);
# Transform(200,0,0,200,0,0);        # double width
# ChangeWeight(-165);
# Move(0,-70);
# Transform(142.85,0,0,142.85,0,0);  # plus shape
# ChangeWeight(-70);
# Move(0,-35);
Transform(164.28,0,0,164.28,0,0);    # plus 1.5x shape
ChangeWeight(-105);
Move(0,-50);
# SetWidth($HAlF,1);
# Move($HAlF,0);
Generate(\$1);
" >/tmp/fontforge.script

  for i in *.ttf ;do
    ditto emdash $i
    fontforge --script /tmp/fontforge.script $i
  done
}

# double width ligatures
explode() {
  if [ $shape ] ;then
    # explode monospace ligature
    echo "
Select($2);
CopyReference();
Select($1);
Paste();
Select($3);
CopyReference();
Select($1);
PasteWithOffset($shape,0);
Select($4);
CopyReference();
Select($1);
PasteWithOffset($5,$6);
SetWidth($(( $shape * 2 )));
"
  else
    # stretch proportional ligature
    echo "
Select($1);
Transform(${width:-200},0,0,100,0,0);
ChangeWeight(-15);
"
  fi
}

ligature() {
  confirm 'add exploded double width ligatures'
  grep -q '^cap =' $REPO/private-build-plans.toml && adjust=21 || adjust=0  # cap extended adjustment
  echo "
Open(\$1);
$(explode 0u00e6 0u0061 0u0065 0u0335 $(( ${shape:-0} / 2 * 3 + 10 )) 0)
$(explode 0u0152 0u004f 0u0045 0u0335 $(( ${shape:-0} / 2 * 3 + 10 )) $(( 118 + $adjust )) )
$(explode 0u0153 0u006f 0u0065 0u0335 $(( ${shape:-0} / 2 * 3 + 10 )) 0)
$(explode 0u01fc 0u0041 0u0045 0u0301 $(( ${shape:-0} / 2 * 3 )) $(( 208 + $adjust )) )
$(explode 0u01fd 0u0061 0u0065 0u0301 $(( ${shape:-0} / 2 * 3 )) 0)
Generate(\$1);
" >/tmp/fontforge.script

  for i in *.ttf ;do
    ditto ligature $i
    fontforge --script /tmp/fontforge.script $i
  done
}

# descending glyphs

move_up()   { [ $raw ]  || echo 'Move(0,32);'; }  # visual alignment at small fontsizes

elongate() {
  # create regular descender
  confirm "$1"
  echo "
Open(\$1);
Select(0u007c);
CopyReference();
Select(0u0001);  # temporary cell to avoid modifying original glyph
Paste();
Select(0u0001);
CopyReference();
Transform(100,0,0,50,0,0);
Select($2);
PasteWithOffset($3,$4);
$(move_up)  # move up a smidgen for small fontsize font (engine) rendering alignment
Select(0u0001);
Clear();
Generate(\$1);
" >/tmp/fontforge.script

  for i in $(regular) ;do
    ditto $1 $i
    fontforge --script /tmp/fontforge.script $i
  done

  # italicize descender from regular glyph and shift to left of cell
  echo "
Open(\$2);
Select($2);
Italic($ANGLE);
Copy();
Open(\$1);
Select($2);
Paste();
Move($Xshift,0);  # adjust for italic side bearing shift towards left 
SetWidth($shape);
Generate(\$1);
" >/tmp/fontforge.script

  for i in $(italic) ;do
    ditto $1 $i
    echo $i | grep -q '[-]italic.ttf' && regular=${i%italic*}regular.ttf || regular=${i%italic*}.ttf
    fontforge --script /tmp/fontforge.script $i $regular
  done
}

I_descending() {
  elongate I_descending '0u0049' 0 $Yshift
}

T_descending() {
  elongate T_descending '0u0054' 0 $Yshift
}

t_descending() {
  elongate t_descending '0u0074' 0 -140
}

Y_descending() {
  elongate Y_descending '0u0059' 0 $Yshift
}

FP_descending() {
  elongate F_descending '0u0046' -162 $Yshift
  elongate P_descending '0u0050' -176 $Yshift
}

Q_horizontal() {
  confirm 'extend horizontal Q'
  echo "
Open(\$1);
$(overlay 0u0051 0u0335 $(( $shape / 4 * 5 )) -225)
Generate(\$1);
" >/tmp/fontforge.script

  for i in *.ttf ;do
    ditto Q_horizontal $i
    fontforge --script /tmp/fontforge.script $i
  done
}

# set book weights as regular (for kindle use with bold weights)
regularweight() {
  echo "
Open(\$2);
Select($1);
Copy();
Open(\$1);
Select($1);
Paste();
Generate(\$1);
"
}

weight() {
  confirm "set $regular weights as regular"
  rm -f *\#1.ttf
  rm -f *.ttx

  # bold **must** be converted too
  fonts="*-$regular *-${regular}italic *-bold *-bolditalic"

  # dump to ttx
  for i in $fonts ;do
    file=$i.ttf
    ditto ttx $file
    ttx $file
  done

  # assign book weights as regular (normal)
  family=${FONT##*/}
  sed -i -e "s/$family ${regular} Version/$family Regular Version/i"       \
      -e "s/$family[ -]${regular}/$family/i"                               \
      -e "s/${regular}/Regular/i"                                          \
      *-${regular}.ttx 

  sed -i -e "s/$family ${regular} Italic Version/$family Italic Version/i" \
      -e "s/$family[ -]${regular}/$family/i"                               \
      -e "s/${regular} Italic/Italic/i"                                    \
      *-${regular}italic.ttx 

  # generate new ttf
  for i in $fonts ;do
    file=$i.ttx
    ditto ttf $file
    ttx $file
  done
  rm -f *.ttx

  if [ $adjust ] ;then
  # optically adjust M W w (to regular weight to narrow stroke width for better small font contrast match)
    echo "
$(regularweight 0u004d)
$(regularweight 0u0057)
$(reglarweight 0u0077)
" >/tmp/fontforge.script

    echo
    for i in *${regular}*\#1.ttf ;do
      ditto tweak_MWw $i
      case $i in
        *italic*) file=*-italic.ttf ;;
        *       ) file=*regular.ttf ;;
      esac
      fontforge --script /tmp/fontforge.script $i $file
    done
  fi

  for i in $(find . -iname '*#1.ttf') ;do ditto weight "$(mv -v $i ${i%#1.ttf}.ttf | cut -d"'" -f4 | sed 's|.*/||')" ;done
}

# double cell width space
dyslexic() {
  if [ $space = "M" ] ;then
    confirm '"M" width space character'
    echo "
Open(\$1);
Select(0u004d);
w = GlyphInfo('Width');
Select(0u0020);
SetWidth(w);
Generate(\$1);
" >/tmp/fontforge.script
  else
    width=$(percent $space)
    confirm "${space}x width space character"
    echo "
Open(\$1);
Select(0u0020);
Transform($width,0,0,100,0,0);
Generate(\$1);
" >/tmp/fontforge.script
  fi

  for i in *.ttf ;do
    ditto space $i
    fontforge --script /tmp/fontforge.script $i
  done
}

copy() {
  confirm "copy $family to $alias"
  rm -f $family*.ttx
  rm -f $alias*.ttf

  # dump to ttx
  for i in $family*.ttf ;do
    ditto ttx $i
    ttx $i
  done

  # new alias
  for i in $family*.ttx ;do
    sed "s/$family/$alias/" $i >$alias${i#$family}
  done

  # generate new ttf
  for i in $alias*.ttx ;do
    ditto ttf $i
    ttx $i
  done
  rm -f *.ttx
}

# map glyph
map() {
  confirm "map $from to $to"
  echo "
Open(\$1);
$(replace 0u$to 0u$from)
Generate(\$1);
" >/tmp/fontforge.script

  for i in $family.ttf ;do
    ditto map $i
    fontforge --script /tmp/fontforge.script $i
  done
}

# main, see iosevka
fforge=$1
case $1 in
  I_descending ) shape=$2; [ $3 = raw ] && { raw=true; shift; }; shift ;;
  T_descending ) shape=$2; [ $3 = raw ] && { raw=true; shift; }; shift ;;
  t_descending ) shape=$2; raw=true; shift ;;
  Y_descending ) shape=$2; [ $3 = raw ] && { raw=true; shift; }; shift ;;
  FP_descending) shape=$2; shift; ;;
  q_hook       ) ;;
  Q_hook       ) ;;
  Q_horizontal ) shape=$2; shift ;;
  Q_custom     ) shape=$2; shift ;;
  ligature     ) [ $4 ] && { width=$2; shift 2; } || { shape=$2; shift; } ;;               # see iosevka for tricky bits
  punctuation  ) emdash=$2; shape=$3; shift 2 ;;
  *weight      ) regular=${1%weight}; fforge=weight; [ "$2" = 'book+regular' ] && { adjust=true; shift; } ;;
  dyslexic     ) [ $2 ] && { space=$2; shift; } || space=2 ;;
  copy         ) [ $3 ] && { family=$2; alias=$3; shift 2; copy; exit; }      || usage ;;  # pwd commandline only!
  map          ) [ $4 ] && { family=$2; from=$3; to=$4; shift 3; map; exit; } || usage ;;  # pwd commandline only!
  *            ) usage ;;
esac
shift
[ $2 ] && usage

FONT=$HOME/.fonts/${1:-Iosevka}
[ $shape ] && HAlF=$(( $shape / 2 ))  # half cell width (see punctuation)
cd $FONT || usage

$fforge

rm -f *.ttx

# vim: set ft=sh: #
