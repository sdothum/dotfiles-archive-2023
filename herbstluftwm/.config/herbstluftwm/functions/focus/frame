# sdothum - 2016 (c) wtfpl
[ $TRACE ] && CHILD="focus/frame $@" . $PARENT

# herbstluftwm
# ══════════════════════════════════════════════════════════════════════════════

# ................................ Find empty subframe to open (spawn) window in

# Usage: focus frame [empty], see draw fsplit

[ -e $DYNAMIC ] || exit

# prevent premature focus window request from conky polling, see query wname
# focus window can shift focus out of an empty frame selected by focus frame above
touch $FOCUS
cpu arm && delay=2 || delay=1
(sleep $delay && rm -f $FOCUS) &

# fill empty grid locations once
# fill=true
unset fill

lock
# do not overlay a window over a fullscreen window, revert to normal view first!
# this prevents a fullscreen window from resizing to a differing monitor geometry
restore windowed
frames=$(query fcount $TAG)

# cycle back to original frame unless empty frame found
herbstclient cycle_frame 1
for i in $(seq 1 $frames) ;do
  herbstclient cycle_frame 1
  # right fill the desktop to to avoid visual frame gaps
  if herbstclient compare tags.by-name.$TAG.curframe_wcount = 0 ;then
    herbstclient focus_edge right >/dev/null 2>&1
    break
  fi
done

for i in $(seq 1 $frames) ;do
  herbstclient cycle_frame 1
  herbstclient compare tags.by-name.$TAG.curframe_wcount = 0 && break
  if [ $i -ge $frames ] ;then
    if [ $fill ] ;then
      # all frames occupied, look for an empty grid region then
      herbstclient cycle_frame -1
      for i in $(seq 1 $frames) ;do
        herbstclient cycle_frame 1
        is layout grid && [ $(expr $(herbstclient attr tags.focus.curframe_wcount) % 2) -gt 0 ] && break
        if [ $i -ge $frames ] ;then
          herbstclient cycle_frame 1
          unset fill
          break
        fi
      done
    fi
  fi
done

# window count of client frame
fcount() { herbstclient attr tags.$(( $(herbstclient attr clients.$i.tag) - 1 )).curframe_wcount; }

# find biggest frame (window) to split -- works best if all frames are max layout (as grids will act to filter window sort)
if [ -z $1 ] && [ -e $FSPLIT ] ;then
  >$FSPLIT
  for i in $(herbstclient list_clients); do 
    set -- $(herbstclient attr clients.$i.content_geometry | sed 's/[-+].*//; s/x/ /')
    [ $1 -gt $2 ] && xy=X || xy=Y  # split along long edge
    count=$(fcount)
    [ $count -lt 1 ] && count=1
    echo $(( $1 * $2 / $count )) $i $xy >>$FSPLIT  # apply multi-window weighting (max layout assumed)
    shift 2
  done
  
  if [ -s $FSPLIT ] ;then
    set -- $(sort -n $FSPLIT | tail -1)
    herbstclient compare tags.focus.curframe_wcount gt 0 && { herbstclient jumpto $2; draw fsplit $3 0.5; }
    shift 3
  fi
fi

unlock

# vim: set ft=sh: #
